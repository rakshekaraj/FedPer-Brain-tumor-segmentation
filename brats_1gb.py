# -*- coding: utf-8 -*-
"""brats-1gb.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rEEdcbbDWh1vsyZY3UgQ0SXfOOsnZhdC
"""

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import zipfile
import cv2
from skimage import io

import tensorflow as tf
from tensorflow.python.keras import Sequential
from tensorflow.keras import layers, optimizers
from tensorflow.keras.layers import *
from tensorflow.keras.models import Model
from tensorflow.keras.initializers import glorot_uniform
from tensorflow.keras.utils import plot_model
from tensorflow.keras.callbacks import ReduceLROnPlateau, EarlyStopping, ModelCheckpoint, LearningRateScheduler
import tensorflow.keras.backend as K

import random
import glob
from sklearn.preprocessing import StandardScaler, normalize
from IPython.display import display
pd.set_option('display.max_colwidth', 50)

df=pd.read_csv('../input/lgg-mri-segmentation/kaggle_3m/data.csv')
df.head()

data_map = []
for sub_dir_path in glob.glob("/kaggle/input/lgg-mri-segmentation/kaggle_3m/"+"*"):
    #if os.path.isdir(sub_path_dir):
    try:
        dir_name = sub_dir_path.split('/')[-1]
        for filename in os.listdir(sub_dir_path):
            image_path = sub_dir_path + '/' + filename
            data_map.extend([dir_name, image_path])
    except Exception as e:
        print(e)

df = pd.DataFrame({"patient_id" : data_map[::2],
                   "path" : data_map[1::2]})
df.head()

df_imgs = df[~df['path'].str.contains("mask")]
df_masks = df[df['path'].str.contains("mask")]


BASE_LEN = 89 
END_IMG_LEN = 4 
END_MASK_LEN = 9 

# Data sorting
imgs = sorted(df_imgs["path"].values, key=lambda x : int(x[BASE_LEN:-END_IMG_LEN]))
masks = sorted(df_masks["path"].values, key=lambda x : int(x[BASE_LEN:-END_MASK_LEN]))

# Sorting check
idx = random.randint(0, len(imgs)-1)
print("Path to the Image:", imgs[idx], "\nPath to the Mask:", masks[idx])

# Final dataframe
brain_df = pd.DataFrame({"patient_id": df_imgs.patient_id.values,
                         "image_path": imgs,
                         "mask_path": masks
                        })
def pos_neg_diagnosis(mask_path):
    value = np.max(cv2.imread(mask_path))
    if value > 0 : 
        return 1
    else:
        return 0
    
brain_df['mask'] = brain_df['mask_path'].apply(lambda x: pos_neg_diagnosis(x))
brain_df.head()

count = 0
i = 0
fig,axs = plt.subplots(5,3, figsize=(20,20))
for mask in brain_df['mask']:
    if (mask==1):
        img = io.imread(brain_df.image_path[i])
        axs[count][0].title.set_text("Brain MRI")
        axs[count][0].imshow(img)
        
        mask = io.imread(brain_df.mask_path[i])
        axs[count][1].title.set_text("Mask")
        axs[count][1].imshow(mask, cmap='gray')
        
        img[mask==255] = (0,255,150)  # change pixel color at the position of mask
        axs[count][2].title.set_text("MRI with Mask")
        axs[count][2].imshow(img)
        count +=1
    i += 1
    if (count==5):
        break
        
fig.tight_layout()

brain_df_train = brain_df.drop(columns=['patient_id'])
# Convert the data in mask column to string format, to use categorical mode in flow_from_dataframe
brain_df_train['mask'] = brain_df_train['mask'].apply(lambda x: str(x))
brain_df_train.info()

from sklearn.model_selection import train_test_split
train, test = train_test_split(brain_df_train, test_size=0.15)

from keras_preprocessing.image import ImageDataGenerator

datagen = ImageDataGenerator(rescale=1./255., validation_split=0.1)

train_generator = datagen.flow_from_dataframe(train,
                                              directory='./',
                                              x_col='image_path',
                                              y_col='mask',
                                              subset='training',
                                              class_mode='categorical',
                                              batch_size=16,
                                              shuffle=True,
                                              target_size=(256,256)
                                             )
valid_generator = datagen.flow_from_dataframe(train,
                                              directory='./',
                                              x_col='image_path',
                                              y_col='mask',
                                              subset='validation',
                                              class_mode='categorical',
                                              batch_size=16,
                                              shuffle=True,
                                              target_size=(256,256)
                                             )
test_datagen = ImageDataGenerator(rescale=1./255.)
test_generator = test_datagen.flow_from_dataframe(test,
                                                  directory='./',
                                                  x_col='image_path',
                                                  y_col='mask',
                                                  class_mode='categorical',
                                                  batch_size=16,
                                                  shuffle=False,
                                                  target_size=(256,256)
                                                 )

brain_df_mask = brain_df[brain_df['mask'] == 1]
brain_df_mask.shape

# creating test, train and val sets
X_train, X_val = train_test_split(brain_df_mask, test_size=0.15)
X_test, X_val = train_test_split(X_val, test_size=0.5)
print("Train size is {}, valid size is {} & test size is {}".format(len(X_train), len(X_val), len(X_test)))

train_ids = list(X_train.image_path)
train_mask = list(X_train.mask_path)

val_ids = list(X_val.image_path)
val_mask= list(X_val.mask_path)

class DataGenerator(tf.keras.utils.Sequence):
    def __init__(self, ids , mask, image_dir = './', batch_size = 16, img_h = 256, img_w = 256, shuffle = True):

        self.ids = ids
        self.mask = mask
        self.image_dir = image_dir
        self.batch_size = batch_size
        self.img_h = img_h
        self.img_w = img_w
        self.shuffle = shuffle
        self.on_epoch_end()

    def __len__(self):
        'Get the number of batches per epoch'

        return int(np.floor(len(self.ids)) / self.batch_size)

    def __getitem__(self, index):
        'Generate a batch of data'

        #generate index of batch_size length
        indexes = self.indexes[index* self.batch_size : (index+1) * self.batch_size]

        #get the ImageId corresponding to the indexes created above based on batch size
        list_ids = [self.ids[i] for i in indexes]

        #get the MaskId corresponding to the indexes created above based on batch size
        list_mask = [self.mask[i] for i in indexes]


        #generate data for the X(features) and y(label)
        X, y = self.__data_generation(list_ids, list_mask)

        #returning the data
        return X, y

    def on_epoch_end(self):
        'Used for updating the indices after each epoch, once at the beginning as well as at the end of each epoch'

        #getting the array of indices based on the input dataframe
        self.indexes = np.arange(len(self.ids))

        #if shuffle is true, shuffle the indices
        if self.shuffle:
          np.random.shuffle(self.indexes)

    def __data_generation(self, list_ids, list_mask):
        'generate the data corresponding the indexes in a given batch of images'

        # create empty arrays of shape (batch_size,height,width,depth) 
        #Depth is 3 for input and depth is taken as 1 for output becasue mask consist only of 1 channel.
        X = np.empty((self.batch_size, self.img_h, self.img_w, 3))
        y = np.empty((self.batch_size, self.img_h, self.img_w, 1))

        #iterate through the dataframe rows, whose size is equal to the batch_size
        for i in range(len(list_ids)):
            #path of the image
            img_path = str(list_ids[i])

            #mask path
            mask_path = str(list_mask[i])

            #reading the original image and the corresponding mask image
            img = io.imread(img_path)
            mask = io.imread(mask_path)

            #resizing and coverting them to array of type float64
            img = cv2.resize(img,(self.img_h,self.img_w))
            img = np.array(img, dtype = np.float64)

            mask = cv2.resize(mask,(self.img_h,self.img_w))
            mask = np.array(mask, dtype = np.float64)

            #standardising 
            img -= img.mean()
            img /= img.std()

            mask -= mask.mean()
            mask /= mask.std()

            #Adding image to the empty array
            X[i,] = img

            #expanding the dimnesion of the image from (256,256) to (256,256,1)
            y[i,] = np.expand_dims(mask, axis = 2)

        #normalizing y
        y = (y > 0).astype(int)

        return X, y

train_data = DataGenerator(train_ids, train_mask)
val_data = DataGenerator(val_ids, val_mask)

# lets create model now
def resblock(X, f): #f = filters
    '''
    function for creating res block
    '''
    X_copy = X  #copy of input
    
    # main path
    X = Conv2D(f, kernel_size=(1,1), kernel_initializer='he_normal')(X)
    X = BatchNormalization()(X)
    X = Activation('relu')(X)
    
    X = Conv2D(f, kernel_size=(3,3), padding='same', kernel_initializer='he_normal')(X)
    X = BatchNormalization()(X)
    
    # shortcut path
    X_copy = Conv2D(f, kernel_size=(1,1), kernel_initializer='he_normal')(X_copy)
    X_copy = BatchNormalization()(X_copy)
    
    # Adding the output from main path and short path together
    X = Add()([X, X_copy])
    X = Activation('relu')(X)
    
    return X

def upsample_concat(x, skip):
    '''
    funtion for upsampling image
    '''
    X = UpSampling2D((2,2))(x)
    merge = Concatenate()([X, skip])
    
    return merge

"""ResUNet model:

The RESUNET consists of an encoding network, decoding network and a bridge connecting both these networks, just like a U-Net. The U-Net uses two 3 x 3 convolution, where each is followed by a ReLU activation function. In the case of RESUNET, these layers are replaced by a pre-activated residual block.

![image.png](data:image/png;base64,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)

Encoder

The encoder takes the input image and passes it through different encoder blocks, which helps the network to learn an abstract representation. The encoder consists of three encoder blocks, which are built using the pre-activated residual block. The output of each encoder block acts as a skip connection for the corresponding decoder block.
To reduce the spatial dimensions (height and width) of the feature maps, the first 33 convolution layer uses a stride of 2 in the second and the third encoder block. A stride value of 2 reduces the spatial dimensions by half, i.e. 256 to 128.

Bridge

The bridge also consists of a pre-activated residual block with a stride value of 2.

Decoder

The decoder takes the feature map from the bridge and the skip connections from different encoder block and learns a better semantic representation, which is used to generate a segmentation mask.
The decoder consists of three decoder blocks, and after each block, the spatial dimensions of the feature map are doubles and the number of feature channels is reduced.
Each decoder block begins with a 22 upsampling, which doubles the spatial dimensions of the feature maps. Next, these feature maps are then concatenated with the appropriate skip connection from the encoder block. These skip connections help the decoder blocks to get the feature learned by the encoder network. After this, the feature maps from the concatenation operation are passes through a pre-activated residual block.
The output of the last decoder passes through a 11 convolution with sigmoid activation. The sigmoid activation function gives the segmentation mask representing the pixel-wise classification.
"""

ResUNet model:

The RESUNET consists of an encoding network, decoding network and a bridge connecting both these networks, just like a U-Net. The U-Net uses two 3 x 3 convolution, where each is followed by a ReLU activation function. In the case of RESUNET, these layers are replaced by a pre-activated residual block

input_shape = (256,256,3)
X_input = Input(input_shape) #iniating tensor of input shape
#ENCODER
# Stage 1
conv_1 = Conv2D(16, 3, activation='relu', padding='same', kernel_initializer='he_normal')(X_input)
conv_1 = BatchNormalization()(conv_1)
conv_1 = Conv2D(16, 3, activation='relu', padding='same', kernel_initializer='he_normal')(conv_1)
conv_1 = BatchNormalization()(conv_1)
pool_1 = MaxPool2D((2,2))(conv_1)

# stage 2
conv_2 = resblock(pool_1, 32)
pool_2 = MaxPool2D((2,2))(conv_2)

# Stage 3
conv_3 = resblock(pool_2, 64)
pool_3 = MaxPool2D((2,2))(conv_3)

# Stage 4
conv_4 = resblock(pool_3, 128)
pool_4 = MaxPool2D((2,2))(conv_4)

# Stage 5 (bottle neck)
conv_5 = resblock(pool_4, 256)
#DECODER
# Upsample Stage 1
up_1 = upsample_concat(conv_5, conv_4)
up_1 = resblock(up_1, 128)

# Upsample Stage 2
up_2 = upsample_concat(up_1, conv_3)
up_2 = resblock(up_2, 64)

# Upsample Stage 3
up_3 = upsample_concat(up_2, conv_2)
up_3 = resblock(up_3, 32)

# Upsample Stage 4
up_4 = upsample_concat(up_3, conv_1)
up_4 = resblock(up_4, 16)

# final output
out = Conv2D(1, (1,1), kernel_initializer='he_normal', padding='same', activation='sigmoid')(up_4)

seg_model = Model(X_input, out)
# seg_model.summary()

from keras.losses import binary_crossentropy

smooth = 1

def iou_coef(y_true, y_pred, smooth=1):
    intersection = K.sum(K.abs(y_true * y_pred), axis=[1,2,3])
    union = K.sum(y_true,[1,2,3])+K.sum(y_pred,[1,2,3])-intersection
    iou = K.mean((intersection + smooth) / (union + smooth), axis=0)
    return iou

# compling model and callbacks functions
adam = tf.keras.optimizers.Adam(lr = 0.05, epsilon = 0.1)
seg_model.compile(optimizer = adam, 
                  loss='mse', #loss='mse', #loss = focal_tversky, 
                  metrics = [iou_coef]
                 )
#callbacks
earlystopping = EarlyStopping(monitor='val_loss',
                              mode='min', 
                              verbose=1, 
                              patience=10
                             )
# save the best model with lower validation loss
checkpointer = ModelCheckpoint(filepath="ResUNet-segModel-weights_v5.hdf5", 
                               verbose=1, 
                               save_best_only=True
                              )
reduce_lr = ReduceLROnPlateau(monitor='val_loss',
                              mode='min',
                              verbose=1,
                              patience=10,
                              min_delta=0.0001,
                              factor=0.2
                             )

h = seg_model.fit(train_data, 
                  epochs = 80, 
                  validation_data = val_data,
                  callbacks = [checkpointer, earlystopping, reduce_lr]
                 )

import subprocess
import pprint

sp = subprocess.Popen(['nvidia-smi'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

out_str = sp.communicate()
out_list = str(out_str[0]).split('\\n')

out_dict = {}

for item in out_list:
    print(item)

plt.figure(figsize=(20,10))
plt.subplot(1,2,1)
plt.plot(h.history['loss']);
plt.plot(h.history['val_loss']);
plt.title("SEG Model mse Loss");
plt.ylabel("mse loss");
plt.xlabel("Epochs");
plt.legend(['train', 'val']);

plt.subplot(1,2,2)
plt.plot(h.history['iou_coef']);
plt.plot(h.history['val_iou_coef']);
plt.title("SEG Model IOU score");
plt.ylabel("IOU Accuracy");
plt.xlabel("Epochs");
plt.legend(['train', 'val']);

plt.savefig('Central_Model_Performance.png')

test_ids = list(X_test.image_path)
test_mask = list(X_test.mask_path)
test_data = DataGenerator(test_ids, test_mask)
_, tv = seg_model.evaluate(test_data)
print("Segmentation IOU is {:.2f}%".format(tv*100))

def prediction(test, model_seg):
    # empty list to store results
    mask, image_id, has_mask = [], [], []
    
    #itetrating through each image in test data
    for i in test.image_path:
        X = np.empty((1,256,256,3))
        # read the image
        img = io.imread(i)
        #resizing the image and coverting them to array of type float64
        img = cv2.resize(img, (256,256))
        img = np.array(img, dtype=np.float64)
        
        # standardising the image
        img -= img.mean()
        img /= img.std()
        #converting the shape of image from 256,256,3 to 1,256,256,3
        X[0,] = img
        
        #make prediction of mask
        predict = model_seg.predict(X)
        
        # if sum of predicted mask is 0 then there is not tumour
        if predict.round().astype(int).sum()==0:
            image_id.append(i)
            has_mask.append(0)
            mask.append('No mask')
        else:
        #if the sum of pixel values are more than 0, then there is tumour
            image_id.append(i)
            has_mask.append(1)
            mask.append(predict)
            
    return pd.DataFrame({'image_path': image_id,'predicted_mask': mask,'has_mask': has_mask})

# making prediction
pd.set_option('display.max_colwidth', 50)
df_pred = prediction(test, seg_model)
df_pred = test.merge(df_pred, on='image_path')
df_pred.head(5)

#visualizing prediction
count = 0
fig, axs = plt.subplots(15,5, figsize=(30,70))

for i in range(len(df_pred)):
    if df_pred.has_mask[i]==1 and count<15:
        #read mri images
        img = io.imread(df_pred.image_path[i])
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        axs[count][0].imshow(img)
        axs[count][0].title.set_text('Brain MRI {}'.format(i))
        
        #read original mask
        mask = io.imread(df_pred.mask_path[i])
        axs[count][1].imshow(mask)
        axs[count][1].title.set_text('Original Mask')
        
        #read predicted mask
        pred = np.array(df_pred.predicted_mask[i]).squeeze().round()
        axs[count][2].imshow(pred)
        axs[count][2].title.set_text('predicted mask')
        
        #overlay original mask with MRI
        img[mask==255] = (255,0,0)
        axs[count][3].imshow(img)
        axs[count][3].title.set_text('Brain MRI with original mask (Ground Truth)')
        
        #overlay predicted mask and MRI
        img_ = io.imread(df_pred.image_path[i])
        img_ = cv2.cvtColor(img_, cv2.COLOR_BGR2RGB)
        img_[pred==1] = (0,255,150)
        axs[count][4].imshow(img_)
        axs[count][4].title.set_text('MRI with PREDICTED MASK')
        
        count +=1
    if (count==15):
        break

fig.tight_layout()

"""<h1>Federated Rounds Start</h1>"""

#initiate a base model

def generate_seg_model():
    input_shape = (256,256,3)
    X_input = Input(input_shape) #iniating tensor of input shape

    # Stage 1
    conv_1 = Conv2D(16, 3, activation='relu', padding='same', kernel_initializer='he_normal')(X_input)
    conv_1 = BatchNormalization()(conv_1)
    conv_1 = Conv2D(16, 3, activation='relu', padding='same', kernel_initializer='he_normal')(conv_1)
    conv_1 = BatchNormalization()(conv_1)
    pool_1 = MaxPool2D((2,2))(conv_1)

    # stage 2
    conv_2 = resblock(pool_1, 32)
    pool_2 = MaxPool2D((2,2))(conv_2)

    # Stage 3
    conv_3 = resblock(pool_2, 64)
    pool_3 = MaxPool2D((2,2))(conv_3)

    # Stage 4
    conv_4 = resblock(pool_3, 128)
    pool_4 = MaxPool2D((2,2))(conv_4)

    # Stage 5 (bottle neck)
    conv_5 = resblock(pool_4, 256)

    # Upsample Stage 1
    up_1 = upsample_concat(conv_5, conv_4)
    up_1 = resblock(up_1, 128)

    # Upsample Stage 2
    up_2 = upsample_concat(up_1, conv_3)
    up_2 = resblock(up_2, 64)

    # Upsample Stage 3
    up_3 = upsample_concat(up_2, conv_2)
    up_3 = resblock(up_3, 32)

    # Upsample Stage 4
    up_4 = upsample_concat(up_3, conv_1)
    up_4 = resblock(up_4, 16)

    # final output
    out = Conv2D(1, (1,1), kernel_initializer='he_normal', padding='same', activation='sigmoid')(up_4)

    seg_model = Model(X_input, out)
    return seg_model

"""<h1>Creating data slices for each client</h1>"""

def create_data_slice(brain_df):
    state_val=random.randint(1, 50)
    test_size_val=round(random.uniform(0.1, 0.2),2)
    data_set_random_frac=round(random.uniform(0.4, 0.8),2)
    
    #randomizing data to simulate real world scenario
    brain_df_mask = brain_df[brain_df['mask'] == 1].sample(frac=data_set_random_frac)
    X_train, X_val = train_test_split(brain_df_mask, test_size=test_size_val, random_state=state_val)
    X_test, X_val = train_test_split(X_val, test_size=0.5)
    
    train_ids = list(X_train.image_path)
    train_mask = list(X_train.mask_path)

    val_ids = list(X_val.image_path)
    val_mask= list(X_val.mask_path)
    
    train_data = DataGenerator(train_ids, train_mask)
    val_data = DataGenerator(val_ids, val_mask)
    
    print("Train size is {}, valid size is {} & test size is {}".format(len(X_train), len(X_val), len(X_test)))
    
    return (train_data, val_data, X_test)

def start_training(model, brain_df, round_no, clinet_no):
    # compling model and callbacks functions
    adam = tf.keras.optimizers.Adam(lr = 0.05, epsilon = 0.1)
    model.compile(optimizer = adam, 
                      loss='mse', #loss = focal_tversky, 
                      metrics = [iou_coef]
                     )
    #callbacks
    earlystopping = EarlyStopping(monitor='val_loss',
                                  mode='min', 
                                  verbose=1, 
                                  patience=10
                                 )
    # save the best model with lower validation loss
    checkpointer = ModelCheckpoint(filepath="ResUNet-segModel-weights_round{}_clinet{}.hdf5".format(round_no, clinet_no), 
                                   verbose=1, 
                                   save_best_only=True
                                  )
    reduce_lr = ReduceLROnPlateau(monitor='val_loss',
                                  mode='min',
                                  verbose=1,
                                  patience=10,
                                  min_delta=0.0001,
                                  factor=0.2
                                 )
    
    train_data, val_data, X_test=create_data_slice(brain_df)
    
    h = model.fit(train_data, 
                  epochs = 3, 
                  validation_data = val_data,
                  callbacks = [checkpointer, earlystopping, reduce_lr]
                 )
    test_ids = list(X_test.image_path)
    test_mask = list(X_test.mask_path)
    test_data = DataGenerator(test_ids, test_mask)
    _, tv = model.evaluate(test_data)
    print("Segmentation IOU is {:.2f}%".format(tv*100))
    
    return (model, h, X_test, tv)

from keras.models import clone_model
# create a model from the weights of multiple models
def fed_avg(members, weights):
    # determine how many layers need to be averaged
    n_layers = len(members[0].get_weights())
    # create an set of average model weights
    avg_model_weights = list()
    for layer in range(n_layers):
        # collect this layer from each model
        layer_weights = np.array([model.get_weights()[layer] for model in members])
        # weighted average of weights for this layer
        avg_layer_weights = np.average(layer_weights, axis=0, weights=weights)
        # store average layer weights
        avg_model_weights.append(avg_layer_weights)
    # create a new model with the same structure
    model = clone_model(members[0])
    # set the weights in the new
    model.set_weights(avg_model_weights)
    model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
    return model

import datetime
def run_federated_rounds(clinet_perround=4, no_of_rounds=8):
    per_round_fedavg_models=[]
    stats=[]
    for i in range(no_of_rounds):
        round_start=datetime.datetime.now()
        this_round_client_trained_models=[]
        sample_size=[]
        print ('')
        print ('')
        print ('***********Federated Round {} **************'.format(i+1))
        for j in range(clinet_perround):
            print ('')
            print ('-------------------------')
            print ('client {} training'.format(j+1))
            if i==0:
                client_model=generate_seg_model()
            else:
                client_model=this_round_fed_avg_model

            model, h , X_test, temp_tv= start_training(client_model, brain_df, i, j)
            sample_size.append(X_test['image_path'].count())
            stats.append({'round': i, 'client': j, 'test_IOU': temp_tv})
            this_round_client_trained_models.append(model)
    
        n_models = len(this_round_client_trained_models)
        wt_sum=sum(sample_size)
        weights=[i/wt_sum for i in sample_size]
        print ("models will be weighted as per below ratio based on their data contribution")
        print (weights)
        this_round_fed_avg_model = fed_avg(this_round_client_trained_models, weights)   
        
        orig_test_ids = list(test.image_path)
        orig_test_mask = list(test.mask_path)
        orig_test_data = DataGenerator(orig_test_ids, orig_test_mask)
        _, tv = this_round_fed_avg_model.evaluate(orig_test_data)
        print("FedAvg Segmentation IOU is {:.2f}%".format(tv*100))
        
        per_round_fedavg_models.append({'round': i, 'fed_avg_model': this_round_fed_avg_model, 'fed_avg_test_IOU': tv})
        round_end=datetime.datetime.now()
        this_round_fed_avg_model.save('FedAvg_Model_Round_{}.hdf5'.format(i))
        print ('Round {} computation done in : {}'.format(i, str(round_end-round_start)))
        print (stats)
    return (per_round_fedavg_models, stats)

(per_round_fedavg_models, stats)=run_federated_rounds()

#final data validation with the averaged model at end of 8 rounds
fed_avg_df_pred = prediction(test, per_round_fedavg_models[-1]['fed_avg_model'])
final_fedavg_df_pred = test.merge(fed_avg_df_pred, on='image_path')

def viz_pred(df_pred, fed_avg_df_pred):
    #visualizing prediction
    count = 0
    fig, axs = plt.subplots(10,7, figsize=(28,50))

    for i in range(len(df_pred)):
        if df_pred.has_mask[i]==1 and final_fedavg_df_pred.has_mask[i]==1 and count<10:
            #read mri images
            img = io.imread(df_pred.image_path[i])
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
            axs[count][0].imshow(img)
            axs[count][0].title.set_text('Brain MRI')

            #read original mask
            mask = io.imread(df_pred.mask_path[i])
            axs[count][1].imshow(mask)
            axs[count][1].title.set_text('Original Mask')

            #read predicted mask(central)
            central_pred = np.array(df_pred.predicted_mask[i]).squeeze().round()
            axs[count][2].imshow(central_pred)
            axs[count][2].title.set_text('AI predicted mask(central)')
            
            #read predicted mask(fed)
            fed_pred = np.array(final_fedavg_df_pred.predicted_mask[i]).squeeze().round()
            axs[count][3].imshow(fed_pred)
            axs[count][3].title.set_text('AI predicted mask(fed)')

            #overlay original mask with MRI
            img[mask==255] = (255,0,0)
            axs[count][4].imshow(img)
            axs[count][4].title.set_text('Brain MRI with original mask (Ground Truth)')

            #overlay predicted mask and MRI
            img_ = io.imread(df_pred.image_path[i])
            img_ = cv2.cvtColor(img_, cv2.COLOR_BGR2RGB)
            img_[central_pred==1] = (0,255,150)
            axs[count][5].imshow(img_)
            axs[count][5].title.set_text('MRI with AI PREDICTED MASK(CENTRAL)')
            
            #overlay predicted mask and MRI
            img_ = io.imread(final_fedavg_df_pred.image_path[i])
            img_ = cv2.cvtColor(img_, cv2.COLOR_BGR2RGB)
            img_[fed_pred==1] = (0,255,150)
            axs[count][6].imshow(img_)
            axs[count][6].title.set_text('MRI with AI PREDICTED MASK(FED)')
            
            count +=1
        if (count==10):
            break
    
#     fig.tight_layout()  
    fig.savefig('Central_VS_Fed.png')

viz_pred(df_pred, final_fedavg_df_pred)

round_wise_clinet_iou={'c1':[], 'c2':[], 'c3':[], 'c4':[], 'c5':[]}
for i in stats:
    if i['client']==0:
        round_wise_clinet_iou['c1'].append(i['test_IOU'])
    if i['client']==1:
        round_wise_clinet_iou['c2'].append(i['test_IOU'])
    if i['client']==2:
        round_wise_clinet_iou['c3'].append(i['test_IOU'])
    if i['client']==3:
        round_wise_clinet_iou['c4'].append(i['test_IOU'])
    if i['client']==4:
        round_wise_clinet_iou['c5'].append(i['test_IOU'])
fig=plt.figure(figsize=(15,10))

plt.plot(round_wise_clinet_iou['c1'])
plt.plot(round_wise_clinet_iou['c2'])
plt.plot(round_wise_clinet_iou['c3'])
plt.plot(round_wise_clinet_iou['c4'])
plt.plot(round_wise_clinet_iou['c5'])
plt.axvline(x=0 )
plt.axvline(x=1.0)
plt.axvline(x=2.0)
plt.axvline(x=3.0)
plt.axvline(x=4.0)
plt.axvline(x=5.0)
plt.axvline(x=6.0)
plt.axvline(x=7.0)
plt.legend(['c1','c2', 'c3', 'c4', 'c5'])
plt.xlabel('Federated Rounds')
plt.ylabel('IOU Score per client')

plt.savefig('clientwise_iou_improvement.png')

import time
while True:
    time.sleep(600)

